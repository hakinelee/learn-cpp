# 23 年 真题记录

> 2023年第14届蓝桥杯省赛 C++ B组



## 1. 日期统计（填空）

**题目大意**：有一个长度为 $100$ 的数组，数组中每个元素的值都是 $0$ 到 $9$ 。数组中的元素从左至右如下所示：

```
5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2
7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1
0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3
```

现从数组中寻找子序列，要求：

1. 子序列的长度为 $8$；
2. 子序列按照下标顺序组成 $yyyymmdd$ 格式的日期，要求日期是 $2023$ 年中的某一天的日期，例如 $20230902$ ，$yyyy$ 表示年份，$mm$ 表示月份，$dd$ 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。

问：计算按上述条件一共能找到多少个**不同**的 $2023$ 年的日期。对于相同的日期你只需要统计一次即可。

**思路**：暴力

**代码**：

```cpp
int main() {
	int arr[100] = {
		5, 6, 8, 6, 9, 1, 6, 1, 2, 4, 
		9, 1, 9, 8, 2, 3, 6, 4, 7, 7, 
		5, 9, 5, 0, 3, 8, 7, 5, 8, 1, 
		5, 8, 6, 1, 8, 3, 0, 3, 7, 9, 
		2, 7, 0, 5, 8, 8, 5, 7, 0, 9, 
		9, 1, 9, 4, 4, 6, 8, 6, 3, 3, 
		8, 5, 1, 6, 3, 4, 6, 7, 0, 7, 
		8, 2, 7, 6, 8, 9, 5, 6, 5, 6, 
		1, 4, 0, 1, 0, 0, 9, 4, 8, 0, 
		9, 1, 2, 8, 5, 0, 2, 5, 3, 3,
	};
	int daysInMonth[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	int ans = 0;
	for(int mon = 1; mon <= 12; ++mon) {
		for(int day = 1; day <= daysInMonth[mon]; ++day) {
			int dateSeq[8] = {2, 0, 2, 3, mon / 10, mon % 10, day / 10, day % 10};
			int k = 0;
			for(int i = 0; i < 100; ++i) {
				if(arr[i] == dateSeq[k]) {
					k++;
					if(k == 8) {
						ans++;
						break;
					}
				}
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```



## 2. 01串的熵（填空）

**题目大意**：对于一个长度为 $n$ 的 $01$ 串 $S=x_1x_2x_3…x_n$，香农信息熵的定义为 $H(S)= -\sum_{1}^{n}p(x_i)\log_{2}(p(x_i)))$，其中 $p(0), p(1)$ 表示在这个 $01$ 串中 $0$ 和 $1$ 出现的占比。

比如，对于 $S=100$ 来说，信息熵 $H(S)=-\frac{1}{3}\log_{2}{\frac{1}{3}} -\frac{2}{3}\log_{2}{\frac{2}{3}} -\frac{2}{3}\log_{2}{\frac{2}{3}}= 1.3083$ 。

对于一个长度为 $23333333$ 的 $01$ 串, 如果其信息熵为 $11625907.5798$，且 $0$ 出现次数比 $1$ 少, 那么这个 $01$ 串中 $0$ 出现了多少次?

**思路**：呵，一眼看出知识点来自通信原理，$01$ 串，那就直接设 $0$ 与 $1$ 的占比为 $x$ 与 $1-x$ ，最终得到信息熵 $H(S)= -\frac{x^2}{n}\log_{2}{\frac{x}{n}}-\frac{(1-x)^2}{n}\log_{2}{\frac{(1-x)}{n}}$

**代码**：

```cpp
double n = 23333333;
double y = 11625907.5798;
double f(double x) {
    double a = x * 1.0 / n;  	   // 0出现的占比
    double b = (n - x) * 1.0 / n;  // 1出现的占比
    double res = 0;
	res -= a * log2(a) * x + b * log2(b) * (n - x);
    return res;
}
int main() {
	for(int i = 1; i < n; i++) {
    	if (abs(f(i) - y) < 0.0001) {
            cout << i << endl;
            break;
        } 
	}
    return 0;
}
```



