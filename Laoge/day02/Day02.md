# Day02：前缀和/差分、尺取法、离散化



## 01 前缀和

一个长度为 $n$ 的数组 $a[1] \sim a[n]$ ，前缀和 $sum[i] $等于 $a[1] \sim a[i] $的和： $sum[i] = a[1] + a[2] + … + a[i]$。

例如：

```cpp
// 原序列 a
int a[7] = {0, 1, 1, 4, 5, 1, 4}; 
// 前缀和 s
int s[7] = {0};
s[1] = a[1];
s[2] = a[1] + a[2];
s[3] = a[1] + a[2] + a[3];
// ...
s[i] = a[1] + a[2] + ... + a[i];
```



利用递推，可以在 $O(n)$ 时间内求得所有前缀和： $sum[i] = sum[i-1] + a[i]$ 。

如果预计算出前缀和，就能利用它快速计算出数组中任意一个区间 $a[i] \sim a[j]$ 的和。即：
    $a[i] + a[i+1] + … + a[j-1] + a[j] = sum[j] - sum[i-1]$

上式说明，复杂度为 $O(n)$ 的区间求和计算，优化到了 $O(1)$ 的前缀和计算。



**模版：**

- 预处理出前缀和 $O(n)$

```cpp
s[1] = a[1];
for(int i = 2; i <= n; ++i)
    s[i] = s[i - 1] + a[i];
```

- 利用前缀和查询（询问）区间和 $O(1)$ 

```cpp
long long calc(int l, int r) {
    return l == 1 ? s[r] : s[r] - s[r] - s[l - 1];
}
```



**B3612 求区间和**

题目大意：给定 $n$ 个正整数组成的数列 $a1, a2, ...  , an$ 和 $m$ 个区间 $[li,ri]$，分别求这 $m$ 个区间的区间和。

思路：预处理出前缀和序列 $S$ ，利用前缀和查询区间和

代码：时间复杂度 $O(n + m)$

```cpp
const int N = 1e5 + 10;
int n, m, l, r, a[N], s[N];
int main() {
	cin >> n;
	for(int i = 1; i <= n; ++i) {
		cin >> a[i];
		s[i] = s[i - 1] + a[i];
	}
	cin >> m;
    // sum[l, r] = s[r] - s[l - 1];
	for(int i = 1; i <= m; i++) {
		cin >> l >> r;
		cout << s[r] - s[l - 1] << endl;
	}
	return 0;
}
```





## 02 差分

与一维数组 $a$ 对应的差分数组 $d$ 的定义： $d[k]=a[k]-a[k-1]$ ，即原数组 $a$ 的相邻元素的差。

根据 $d$ 的定义，可以推出： $a[k]=d[1]+d[2]+…+d[k]$ ，即 $a$ 是 $d$ 的前缀和，所以**差分是前缀和的逆运算**。

例如：

给定一个原数组 $a$ ：$a[1], a[2], a[3], ... , a[n];$

构造一个数组 $b$  ： $b[1], b[2], b[3], ... , b[i]$;

使得 $a[i] = b[1] + b[2] + b[3] + , ... , + b[i];$

也就是说， $a$ 数组是 $b$ 数组的前缀和数组，反过来 $b$ 数组叫做 $a$ 数组的差分数组。换句话说，每一个 $a[i]$ 都是 $b$ 数组中从头开始的一段区间和。



为方便理解，把每个a[]看成直线上的坐标。每个d[]看成直线上的小线段，它的两端是相邻的a[]。这些小线段相加，就得到了从起点开始的长线段a[]。



**模版：**

- 差分序列的求法 $O(n)$

```cpp
c[1] = a[1];
for(int i = 2; i <= n; ++i)
    c[i] = a[i] - a[i - 1];
```

- 原序列上区间 $[l , r]$ 修改（区间加/减）相当于差分序列上两个单点修改 $O(1)$ 

```cpp
c[l] += v;
c[r + 1] -= v;
```
> 询问：给定一个参数，回答一定信息。
>
> 操作：对原序列进行修改。




**P2367 语文成绩**

题目大意：给定 $n$ 个同学的初始成绩，现需要给某些同学增加分数，又要注意最低分。输入 $x$ ， $y$ ， $z$ ，代表给第 $x$ 个到第 $y$ 个学生每人增加 $z$ 分。

思路：预处理出差分序列 $S$ ，差分序列两个单点修改，然后利用差分序列逆推出修改后的原序列，最后排序。

> 这题的思路可以进一步优化，利用差分序列求出原序列后，可以通过遍历获取最小值。时间复杂度 $O(n+m+n)$

代码：时间复杂度 $O(n + m + log n)$

```cpp
const int N = 1e5 + 10;
int n, m, l, r, a[N], s[N];
int main() {
	cin >> n;
	for(int i = 1; i <= n; ++i) {
		cin >> a[i];
		s[i] = s[i - 1] + a[i];
	}
	cin >> m;
    // sum[l, r] = s[r] - s[l - 1];
	for(int i = 1; i <= m; i++) {
		cin >> l >> r;
		cout << s[r] - s[l - 1] << endl;
	}
    sort(a + 1, a + n + 1);
    cout << a[1];
    return 0;
}
```


**P4552  IncDec Sequence**

题目大意：给定一个长度为 $n$ 的数列 $a1,a2,⋯,an$ ，每次可以选择一个区间 $[l,r]$ ，使这个区间内的数都加 $+1$ 或者都减 $-1$ 。至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。

思路：
```
最少操作次数：max{ 正数绝对值之和 , 负数绝对值之和 } 
最终数列种数：abs{ 正数绝对值之和 - 负数绝对值之和 } + 1
```

代码：
```cpp
const int N = 1e5 + 10;
int a[N];
int main() {
	int n;
	cin >> n;
	for(int i = 1; i <= n; ++i)
		cin >> a[i];
	for(int i = n; i >= 1; --i)
		a[i] = a[i] - a[i - 1];
	// 从第2项到第n项中，正数绝对值之和 sum1 , 负数绝对值之和sum2 
	long long sum1 = 0, sum2 = 0;	
	for(int i = 2; i <= n; ++i)
		if(a[i] > 0)
			sum1 += a[i];
		else
			sum2 -= a[i];
	// 最少操作次数：max{ 正数绝对值之和 , 负数绝对值之和 } 
	// 最终数列种数：abs{ 正数绝对值之和 - 负数绝对值之和 } + 1
	cout << max(sum1, sum2) << endl;
	cout << abs(sum1 - sum2) + 1 << endl;
	return 0;
}
```








